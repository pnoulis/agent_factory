* About
Documentation for the Backend API and architecture of the Client.


* The Command pattern

The *afmachine* or *afm* for short is the control center of the application.

It's API is consumed by invoking any of the public methods of the *afm*
instance.

All API calls are stored under the directory:

/src/afmachine/tasks/*
/src/afmachine/synthetic-tasks/*

Each of these is usually a wrapper for a backend API call.

The backend API calls are found at:

/src/afmachine/device/admin-screen/*
/src/afmachine/device/rpi-reader/*

The primary function of *Afmachine* is to allow clients (such as a React
component or the UI in general) to build middleware chains around each Task.
This design model follows loosely the *command* design pattern. see
(https://en.wikipedia.org/wiki/Command_pattern)

Each time an API call is made *afm* creates a *Command* for the invoked *Task*.
A *Command* represents one instance of a running *Task*.

For example: If a client was to invoke an API call multiple times:

afm.listPkgs()
afm.listPkgs()
afm.listPkgs()

There would be 3 *Commands* created for the listPkgs *Task*.

Each *Command* carries with it a lot of information but fundamentally it
contains a sequence of functions (the middleware chain) to run.

When a command is created it is placed into a queue by afm. The afm is
responsible for invoking each the commands in the queue in sequence (meaning in
order, waiting for the completion of one to carry on with the next).

For example: If a client was to invoke the API calls:

afm.loginCashier();
afm.listPkgs();
afm.logoutCashier();

There would be 3 *Commands* to run in the queue by *afm*.
It would proceed by running them in these order:

1. loginCashier()
2. listPkgs()
3. logoutCashier()

Clients to afm can register functions that become part of a Command through the
Eventful interface at:

/src/Eventful.js

For exmaple:

// Register a hook to run before each command in the queue.
afm.on('precmd', (afm) => {});

// Register a hook to run after each command in the queue.
afm.on('postcmd', (afm) => {});

// Register a hook to run before each Command for the listPkgs Task.
afm.listPkgs.on('precmd', (command, next) => {});

// Register a hook to run after each Command for the listPkgs Task.
afm.listPkgs.on('postcmd', (command, next) => {});


* Conventions
** Command inputs and outputs
#+begin_src js
  {
    args: {
      ...AFM_FORM_INPUTS
    }
    req: {
      ...BACKEND_FORM_INPUTS
    }
    raw: {
      ...BACKEND_FORM_OUTPUTS
    }
    res: {
      ...AFM_FORM_OUPUTS
    }
  }
#+end_src
** Commands wrap their return value within an object
Commands never return an entity object, they return an object that contains the
entity or entities.

#+begin_src js
  // Instead of:
  const response = {
    username: "...",
    name: "...",
  }

  // This:
  const response = {
    player: {
      username: "...",
      name: "...",
    },
  }
#+end_src



* Normalization functions
Normalization function take an array of source objects and combines them into
one object. It is similar to Object.assign(target, ...sources) but adjusted to
fit the special needs of the ENTITY being normalized. (such as a Player,
Wristband etc). To be more exact, each normalization function is responsible
for:

- TRANSLATION of an object in backend form to frontend form.
- DEDUCING the state of the entity.
- MERGING of multiple sources in any form.
- NORMALIZATION of the NESTED entities contained within, if any.

** Inputs
All normalization functions accept the following inputs:

- an array of sources, or a single object, or null, or the empty object etc...
- An Options object

To pass along instructions to a NESTED normalization function, one must begin a
secondary nesting in the Options object.

For example:

#+begin_src js
  // Considering a Composite Entity such as a Team which
  // contains within Players with each owning a Wristband and Packages.
  // Team -> Players -> Wristband
  // Team -> Packages
  {
    nullSupersede: true, // Team target
    state: 'registered', // Team Target
    package: { // NESTED TARGET -> Package
      state: "playing",
    }
    player: { // NESTED TARGET -> Player
      state: "inTeam",
    }
    wristband: { // NESTED TARGET -> Player -> Wristband
      state: "paired",
      nullsSupersede: false
    }
  }
#+end_src

** Deducing state
Deducing state is carried on in 2 stages. The goal is to reduce ambiguity an
introduce Determinism.

The first stage is about interpreting the properties that carry with them State.

For example, given a Package with a non-nil id property:

#+begin_src js
  // Package
  {
    id: 5
  }
#+end_src

I could interpret the existence of a non-nil ID property as indicative of
the Package being at least Registered.

But I do not (not in the 1st stage). The only properties used in the first stage
in that EXACT order of a Package normalization function are:

- targetState
  The targetState is passed as an option to the normalization function.
  If it has been defined it interrupts the function and returns immediately
  operating under the assumption that the caller already knows what
  the state of the target should be.
- active
  This property is found in a BackendForm package. If it is defined and true
  it means the Package is currently active.
- state
  This property is found in an AfmForm package.
- defaultState
  The defaultState is passed as an option to the normalization function.
  If no state has been deduced so far in the process, it is used.

The general pattern is that, the targetState has the highest precedence. It is
followed by State backendForm, then by afmForm State, then by defaultState.

In the tobject() functions which must also deduce state the order is:
targetState, afmForm, defaultState.

This is the end of the 1st stage.

The 2nd stage is responsible for binding the Content of the entity to its State.

What do I mean by that?.

Some properties such as:

state or active (in a Package)

are explicitly designed to convey state.

While the other properties in a Package are about its Contents.

#+begin_src js
  {
    id,
    t_started,
    t_ended,
    remainder,
    amount,
    ...
  }
#+end_src

Therefore, one may allocate each Property as belonging to:

- State
- Content

So the 2st stage is about making sure that the target's Contents align with the
State from the 1st stage.

So again carrying on with the above Example:

A Package can be in one of four states:

- Unregistered
- Registered
- Playing
- Completed

(-START NOTE-)
I believe that the architecture of the backend should be based on Packages.
What do I mean?
Instead of having Teams with Packages and Teams having an active Package.
You have Packages with a 'has-a' Team.
So instead of (1)Team-(*)Packages you have a (1)Package-(1)Team.
But it is not, so I make best with what I have.
(-END NOTE-)


Lets say that the target after stage 1 looks like these:

#+begin_src js
  {
    state: 'unregistered'
    id: 5,
    t_start: 100,
    t_end: 500,
  }
#+end_src

This is an example of a misalignment. The State says that this Package
is unregistered but the Contents say that it is Completed.

What should be done in this situation?

In order to help the developer know when a situation like this arises a
state Error is thrown.

So the 2nd stage is responsible for making sure that a misalignment never
occurs.




* Schemas
** Package
*** AFM Time
#+begin_src js
  {
    id: 3,
    name: 'Per Time 90',
    amount: 99999 // milliseconds
    type: "time",
    cost: 90.99,
    amount: 888, // milliseconds,
    remainder: 123, // milliseconds,
    t_start: 1232434324, // milliseconds,
    t_end: 1234234234, // milliseconds
    state: "unregistered" | "registered" | "playing" | "completed"
  }
#+end_src
*** AFM Missions
#+begin_src js
  {
    id: 3,
    name: 'Per Mission 5',
    amount: 5 // missions
    type: "mission",
    cost: 90.99,
    amount: 5, // missions
    remainder: 1, // missions,
    t_start: 1232434324, // milliseconds,
    t_end: 1234234234, // milliseconds
    state: "unregistered" | "registered" | "playing" | "completed"
  }
#+end_src
*** Backend Time
#+begin_src js
  // team's package
  {
    id: 5,
    name: 'Per Time 90',
    cost: null,
    started: 1706685129723, // milliseconds
    ended: null, // milliseconds
    duration: 5400, // seconds
    paused: false,
    active: true
  }
#+end_src
*** Backend Missions
#+begin_src js
  // team's package
  {
    id: 1,
    name: 'Per Mission 5',
    cost: null,
    started: null, // milliseconds
    ended: null, // milliseconds
    missions: 5, // missions
    missionsPlayed: 0, // missions
    active: false
  }
#+end_src
*** Available Backend packages
#+begin_src js
  // Missions
  {
    name: "Per Mission 5",
    amount: 5, // Missions
    type: "mission",
    cost: 150
  }

  // time
  {
    name: "Per Time 90",
    amount: 90, // minutes
    type: 'time',
    cost: 150
  }
#+end_src
** Device
*** AFM rpi reader
#+begin_src js
  {
    id: 'ADMINISTRATION1Reader',
    type: 'RPI_READER',
    room: 'ADMINISTRATION1'
  }
#+end_src
*** AFM admin screen
#+begin_src js
  {
    id: '001',
    type: 'REGISTRATION_SCREEN',
    room: 'ADMINISTRATION1'
  }
#+end_src
*** Backend
#+begin_src js
  {
    deviceId: '001',
    deviceType: 'REGISTRATION_SCREEN',
    roomType: 'ADMINISTRATION1'
  }
#+end_src
** Cashier
*** AFM
#+begin_src js
  {
    id: 4394,
    username: '80teepo7fu9',
    email: '80teepo7fu9@gmail.com',
    role: 'manager'
  }
#+end_src
** Player
*** AFM
#+begin_src js
  {
    username: "test"
    name: "testname",
    surname: "testsurname",
    email: "test@gmail.com",
    state: 'unregistered' || 'registered' || 'inTeam' || 'playing'
    wristband: {
      id: null || 3,
      color: null || 'green',
      colorCode: null || 3,
      state: "unpaired" || "pairing" || "unpairing" || "paired"
    }
  }
#+end_src
*** Backend
#+begin_src js
  {
    username: "test",
    name: "test",
    surname: "test",
    email: "test@gmail.com",
    wristbandMerged: true || false,
  }
#+end_src
** Team
** Wristband
*** AFM
#+begin_src js
  {
    id: 3,
    color: "green",
    colorCode: 2,
    state: "unpaired" || "pairing" || "unpairing" || "paired"
  }
#+end_src
*** Backend
#+begin_src js

  // wristband register
  {
    timestamp : 1706957679789,
    username : "diwgp3nrrtf",
    wristbandNumber : 234
  }

  // wristband deregister
  {
    timestamp : 1706960913123,
    result : "OK",
    message : "successfully unregisterWristbandToPlayer"
  }

  // wristband info
  {
    timestamp: 1706879364557,
    result: 'OK',
    wristband: { wristbandNumber: 3, wristbandColor: 2, active: false }
  }

  // wristband scan
  {
    timestamp: 1706880614077,
    result: 'OK',
    wristbandNumber: 3,
    wristbandColor: 3
  }


  // list registered players + search players
  {
    username: 'Merry_2mpmnxcgv1s',
    name: 'Merry',
    surname: 'compassionate',
    email: 'Merry@gmail.com',
    wristbandMerged: false,
    wristband: null
  },
  {
    username: 'Wormtongue_klagnkjxqla',
    name: 'Wormtongue',
    surname: 'jovial',
    email: 'Wormtongue@gmail.com',
    wristbandMerged: false,
    wristband: { wristbandNumber: 230, wristbandColor: 3, active: true }
  },

  // list registered players with writband
  {
    username: 'Gandalf_deil7sv8j4c',
    name: 'Gandalf',
    surname: 'busy',
    email: 'Gandalf@gmail.com',
    wristbandMerged: false,
    wristband: { wristbandNumber: 233, wristbandColor: 4, active: true }
  },

  // list teams
  players: [
    {
      username: 'test1',
      wristbandNumber: null,
      wristbandColor: null
    },
    {
      username: "test3",
      wristbandNumber: 1,
      wristbandColor: null,
    },
    {
      username: "test4",
      wristbandNumber: null,
      wristbandColor: 2,
    },

    {
      username: "Sauron_0h96h9q4xixv",
      wristbandNumber: 241,
      wristbandColor: 2,
    },

  ]
#+end_src



