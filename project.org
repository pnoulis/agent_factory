* Communication between objects
The *afmachine* acts as the *Invoker* in the *Command* pattern. It is the
control center of the application. All actions that touch multiple modules of
the system are managed and directed towards those systems by the control center.

A command is an action that has to be carried out at some point in the future.
Each command may be comprised of multiple subtasks that need to be performed,
where order is important just like in the middleware pattern. Eeach subtask adds
or performs some kind of processing to the context passed along. When all
subtasks are finished the command is considered settled, (to borrow a promise
term) and interested parties are notified.

All entities that initiate commands are *clients* to the afmachine. It is rather
common for a client, to also be a target of the command; albeit at a later stage
of the command's lifecycle.

The modules that are supposed to process the command are the *targets* of the
command.

The management, monitoring and guidance of a command from its inception to its
end is handled by the afmachine. Specifically, clients do not initiate commands,
rather, they ask afmachine to do that for them.

Commands are composed of a queue of tasks that need to be executed. Each task is
intended to be consumed by a target.

* Afmachine

The Afmachine or afm for short is the control center of the application. It is a
singleton object. All browser windows and tabs share the SAME object.

All entities such as:

- the Player, Team..., ...Package
- A React Component
- The Administrator interacting with the application by clicking on buttons etc

make use of the afm API and are collectively known as clients. The afm API
is accessed through methods of the afm singleton object.

A standard interaction between a client and afm might go as follows:

- A client initiates an event through the use of a React component such as by
  clicking on a button.
  
- The React component invokes an API method of afm.
  
- Afm instantiates a Command
  
  The instance is returned synchronously.

  Each method of Afm represents some kind of Task such as logging in the
  administrator or pairing a Wristband. These tasks are defined at application
  initialization time. A Command represents an instance of running the Task.

  Some tasks return promises other tasks accept callbacks. If the Task is
  is designed to be called through an Entity usually expected to be called through an Entity it

- Afm enqueues the new Command.
  
  If the queue is empty the Command is immediately invoked. Otherwise it waits for its turn.
  
- Afm returns a Promise that will be fulfilled with the fulfillment value of the
  Command.
  
- Afm emits various events such as:

  onNewCommand
  commandStart

* New afmachine


player._pairWristband(...args) {
}

player.pairWristband(...args) {
...
}

afm.player.pairWristband(player, ...args, cb);

function afm.player.pairWristband() {
const cmd = createCommand();
cmd.notify();
cmd.enqueue();
cmd.run();
}

function afm.listPkgs() {
const cmd = createCommand();
cmd.notify('start');
cmd.abort();
cmd.enqueue();
cmd.run();
}

afm.createCommand();
afm.notify();
// may abort or continue command



Tasks return a Command Promise and accept a CB.

* Application initialization TIME

The afm SINGLETON is instantiated.
All afm API calls are created through the createTask() function.

Each Task inherits from the Eventful class.

This interface allows clients to attach event listeners at all stages of a
Commands lifecycle.

To invoke a Task means to create a new Command for that Task.

A task is guaranteed to initialize a Command asynchronously.

task.on('command')

Each task returns a Command object.

const cmd = task();


afm.runCommand(cmd, cb);

* Command Targets
Command Targets should not need to know if a command was aborted or not.
Command targets are notified through CALLBACKS not Promises.

A callback interface is used to prevent dangling promises.
In case a command is aborted or an error occurs in the application level the
callback shall never be called.

* Tasks
** List packages

* User stories
** Administrator toggles wristband pairing mode
In order for the administrator to be able to toggle a wristbands pairing mode
the following components are required:

UI component that handles a user click
A Player instance

The player hook is a wrapper to the Player class. The hook exposes the player's
interface to

