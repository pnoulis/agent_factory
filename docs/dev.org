* Agent factory cloud storage
** gdrive via rclone
https://rclone.org/drive/#making-your-own-client-id
* scoreboard development
** 3 secs updates
/themaze/scoreboard/response

topic: /themaze/backend

Data returned from /themaze/backend:

- Are they limited to the teams of the day?
  If yes then which topic retrieves a full history?

- Required data points
  won
  lost,
  time used
  played,

** How are rooms organized.
*** limited data formate

#+begin_src json

  {
    "teamName" : "team13",
    "totalPoints" : 210
  }
  #+end_src
  
*** per room
Full history
*** per element
full history
*** live
The teams are limited to:

1. have an activated package
2. Last attempt < 30 minutes


#+begin_src json

  {
    "teamName":"team6",
    "numberOfPlayers":2,
    "timeUsed":"",
    "played":10,
    "won":10,
    "lost":0,
    "totalPoints":754
  },


#+end_src

*** Team monthly

Their last successfull attempt to join a room has
been within the last Month.

*** Team daily

Last attempt within > 00:00 (midnight).

Each room (roomId, roomName) 

* Deployment targets
** server at work through LAN
ssh host: afserver.local
ssh host port: 22
username: Mindtrap
password: 123
mqtt port: 9001
server root path: C:laragon/www/administration
** localhost at devmachine
** server at devmachine
** public testing server
* Release procedure
** Prepare a new release.sh
The release.sh script is used to identify the latest release.

The preparation of a new release requires:

1. The selection of a new commit from each submodule to go into the new release.
   for example, the latest commit.
2. Updating of the commit hash and other metadata within release.sh.
   (check release.sh for an example of a commit description)
3. Run release.sh through make (make release) to ensure that each submodule of
   the monorepo is at the specified commit.

** run make release

release.sh requires for all submodules that:

1. The working tree is clean
2. That the remote repository contains all new changes of the current branch
3. That a release branch exists and points to the specified release commit
4. That it builds successfully

** new release process
The new release procedure performs the following steps:

*** Demand clean working directories for each submodule
*** Request a new version number
*** Produce a new PROJECT
*** produce a new CHANGELOG
*** produce a new package.json
*** produce a RELEASE

The new release process does not require explicitly specifying commits for
submodules.

Rather, release.sh creates a new release based off the currently checked out
commit for each submodule.

If a submodule's working directory is dirty the new release is aborted.

* Issue new Makefile that makes use of new DOTENV for each submodule
** DONE mqtt_proxy
CLOSED: [2023-07-04 Tue 21:41]
** DONE refactor_afmachine
CLOSED: [2023-07-04 Tue 21:55]

** DONE js_utils
CLOSED: [2023-07-04 Tue 22:03]
** DONE react_utils
CLOSED: [2023-07-04 Tue 22:03]
** DONE refactor.afadmin_client
CLOSED: [2023-07-04 Tue 22:03]
* Write scripts that make use of the serviceBackend API for testing and development purposes
** DONE environment loading
CLOSED: [2023-07-09 Sun 09:07]
The scripts depend on services which read the environment at runtime. As such if
the expected symbols are not defined at the appointed location they are unable
to initialize and fail.
** DONE registerPlayers
CLOSED: [2023-07-10 Mon 09:08]
** DONE registerWristbands
CLOSED: [2023-07-10 Mon 09:08]
** DONE registerTeams
CLOSED: [2023-07-10 Mon 09:08]
** DONE addPackage
CLOSED: [2023-07-10 Mon 09:08]
** DONE startTeam
CLOSED: [2023-07-10 Mon 09:08]
* Write a script that resets the backend database for testing and development purposes
** DONE flushBackendDB
CLOSED: [2023-07-10 Mon 09:08]

* DONE Transfer emulateScan to scripts/
CLOSED: [2023-07-10 Mon 19:11]

* DONE Rudimentary tests all api calls
CLOSED: [2023-07-10 Mon 20:50]
** DONE infoWristband
CLOSED: [2023-07-10 Mon 19:58]
** DONE listTeams
CLOSED: [2023-07-10 Mon 20:05]
** DONE loginPlayer
CLOSED: [2023-07-10 Mon 20:13]
** DONE searchPlayer
CLOSED: [2023-07-10 Mon 20:20]
** DONE mergeGroupTeam
CLOSED: [2023-07-10 Mon 20:37]
** DONE subscribeWristbandScan
CLOSED: [2023-07-10 Mon 20:50]


* TODO Afmachine
The afmachine is a superclass holding multiple objects.
It basically extends the BackendService.
** DONE Move pipeline to js_utils
CLOSED: [2023-07-11 Tue 09:33]

** DONE Rename afmachine/src/afmachine to afmachine/src/entities
CLOSED: [2023-07-11 Tue 09:45]

** DONE Check environment is loaded at afmachine
CLOSED: [2023-07-11 Tue 10:10]

** TODO Import backend service and logger service
** TODO Different pairing definition
* LOG 17/07/23
** Player registration
* LOG 18/07/23
sessionId
slaves
clientId


* LOG 19/07/23
** registerUser
** Form error handling
In case of validation errors the form should display a message one for each of the
perpetrator fields displayed beneath the field itself.
** Routes input/output standardaziation
*** Route input

#+begin_src js

  // All routes at invocation time are designed to receive a variable number of arguments.
  function route(...args) {};

  // At which point the route shall construct a new context object.
  const context = {
    args,
    req: {},
    res: {},
  }

  // And pass it along the middleware chain, where each middleware will most propably
  // perform its own mutations to the context object.

#+end_src

*** Creating the request object
#+begin_src js

  // The first middleware of each route pipeline parses its argument list into the
  // proper request object.

  /* Example

     Consider the case where the registerPlayer() route is provided with the following
     arguments:

     Afmachine.registerPlayer({username: "oetuheontuh"}, options);

     The Route instance shall create the following context object:
  ,*/

  const context = {
    args = [ { username: "toehuneotuh", }, options ]
    req: {},
    res: {},
  }

  /*
    The first middleware responsible for parsing the arguments will proceed to
    mutate the context object in a similar fashion:
  ,*/

  function constructRequestObject(context, next) {
    const [request = {}, options = {}] = context.args;
    context.req = {
      timestamp: Date.now(),
      username: request?.username || "",
      surname: request?.surname || "",
      name: request?.name || "",
      email: request?.email || "",
      password: request?.password || "",
    }
    await next();
  }

#+end_src

*** Creating the response object
#+begin_src js

  // Following from the player example of the previous heading

  // Given the response

  const { result = "OK", timestamp: 123434324, player = { username: 'oethuen', ...props }, } = backendService.registerPlayer();

  // The following middleware shall mutate it to:

  function constructResponseObject(context, next) {
    context.res.payload = {
      msg: `Registered player ${player.username}`;
      data: {
        name: player?.name,
        surname: player?.surname,
        username: player?.username,
        email: player?.email,
      }
    }
  }

#+end_src
*** Route output
#+begin_src js

  // At the end of the middleware pipeline the result shall be
  // either a thrown exception or a portion of the context object


  // For example, given the following context object at the end of a pipeline
  const context = {
    args: [player, options],
    req: {
      timestamp: 123424,
      username: 'yolo',
      ...props,
    }
    res: {
      result: "OK",
      timestamp: 1234234,
      player: {
        username: 'yolo',
        ...props
      }
      payload: {
        msg: "registered player yolo",
        data: {
          username: 'yolo',
          ...props,
        }
      }
    }
  }

  // The output of the pipeline shall be:

  const output = {
    route: "/register/player",
    req,
    res: {
      msg: "registered player yolo",
      data: {
        username: "yolo",
        ...props,
      }
    }
  }


#+end_src


* LOG 20/07/23
** DONE test route registerPlayer
CLOSED: [2023-07-20 Thu 10:32]
** DONE test route searchPlayer
CLOSED: [2023-07-20 Thu 10:32]
** TODO ComboboxSearchPlayer
* LOG 21/07/23
** TODO player info cards
* LOG 22/07/23
** Data normalization
The frontend and backend systems that make up agent_factory do not use the same
schemas for their standard entities. Take notice that the entities returned by
the backend api may not correspond to the actual database schema used internally
by the backend system itself. For example the backend defines a wristband as an
object with the following properties.

#+begin_src js

  // Wristband schema as defined within the backend system
  const backendWristband = {
    wristbandNumber: Integer,
    wristbandColor: Integer
    active: Boolean
  }

#+end_src

In my opinion the backend's implementation of the wristband schema could have
been better or equally served its purpose if it was defined differently, which
is why the frontend introduces a new wristband schema. More than that the
frontent must make sure to conserve its memory footprint for reasons of network
speed and other such constraints or for optimization reasons.

#+begin_src js

  // Wristband schema as defined within the afmachine subsystem
  const afmachineWristband = {
    id: Integer,
    color: Integer,
    status: String,
  }

#+end_src

Given that example, *Data normalization* refers to the process that maps backend
schemas as returned by their *api* not by the actual *db schema* to the frontend
schemas.

I proceed by documenting

1. Database schemas
2. Backend api schemas
3. Frontend schemas
4. Frontend class entities

*** Wristband schema

#+begin_src js

  // Database schema
  const dbSchema = {
    id: bigint,
    created: datetime,
    updated: datetime,
    active: bit,
    wristband_color: varchar(255),
    wristband_number: int,
  }

  // Backend API
  const BWristband = {
    wristbandNumber: Integer,
    wristbandColor: Integer,
    active: Boolean,
  }

  // Frontend mappings
  const FWristband = {
    id: Integer,
    color: Integer,
    state: String, // unpaired, pairing, paired, registered
  }

#+end_src

*** Player schema

#+begin_src js

  // Database schema
  const dbSchema = {
    id: bigint,
    created: datetime,
    updated: datetime,
    email: varchar(255),
    is_temporary: bit,
    name: varchar(255),
    online_account: bit,
    password: varchar(255),
    surname: varchar(255),
    username: varchar(255),
    wristband_merged: bit,
    registered_wristband_id: bigint,
  }

  // Backend API
  const BPlayer = {
    name: String,
    surname: String,
    email: String,
    username: String,
    wristbandMerged: Boolean,
    // The B in BWristband is an abbreviation for 'Backend', the entity
    // defined within the Wristband schema entry.
    wristband: BWristband
  }

  // Frontend mappings
  const FPlayer = {
    name: String,
    surname: String,
    email: String,
    username: String,
    // The F in FWristband is an abbreviation for 'Frontend', the entity
    // defined within the Wristband schema entry.
    wristband: FWristband,
    state: String, // forming, registered, inTeam, inGame
  }

#+end_src

*** Package schema

#+begin_src js

  // Database schema
  const dbSchema = {
    type: varchar(31)
    id: bigint, // auto increment
    created: datetime(6),
    updated: datetime(6),
    cost: double,
    ended: datetime(6),

    // Signifies, if true, that amongst the set of packages owned by a team, this
    // one is the one currently being used.
    is_active: bit,

    name: varchar(255),
    started: datetime(6),
    missions: bigint,
    missions_played: bigint,
    duration: decimal(21,0),

    // Signifies, if true, that the package is currently being *spend*. To spend a
    // package means to play it. In particular a *TIME* package is being spend
    // when it has run out of time. a *MISSIONS* package is spend when all if its
    // missions have been played and so on...
    is_paused: bit(1),
    team_id: bigint,
  }

  // Backend API
  // The contents of a BPackage is not uniform across all api calls.

  // For example the listPackages route is intended to be used within the package
  // selection and forming process. On the other hand the listTeams route returns
  // a 'live' package, a package which has been added to a team. That package
  // object carries more information within it and its contents are dependent on
  // the type of the package.

  // Backend Package as returned by listPackages
  const listPackagesPackage = {
    name: String,
    amount: Integer,
    type: String,
    cost: Integer,
  }

  // Mission type package as returned by listTeams
  const listTeamsMissionType = {
    id: Integer,
    name: String,
    cost: Real,
    started: Integer, // timestamp
    ended: Integer, // timestamp
    missions: Integer,
    missionsPlayed: Integer,
    active: Boolean
  }

  // Time type package as returned by listTeams
  const listTeamsTimeType = {
    id: Integer,
    name: String,
    cost: Real,
    started: Integer, // timestamp
    ended: Integer, // timestamp
    duration: Integer,
    paused: Boolean,
    active: Boolean,
  }

  // All BPackage properties combined
  const CombinedBPackage = {
    id: Integer,
    name: String,
    cost: Real,
    started: Integer,
    ended: Integer,
    active: Boolean,
    type: String,
    amount: Integer,
    duration: Integer,
    paused: Boolean,
    missions: Integer,
    missionsPlayed: Integer,
  }

  // Frontend Mappings
  const FPackage = {
    id: Integer,
    name: String,
    type: String,
    cost: Real,
    amount: Integer,
    started: Integer,
    ended: Integer,
    remainder: Real,
    state: String, // forming, unpaid, paid, playing, paused, completed
  }

#+end_src

*** Roster schema

#+begin_src js

  // Database schema
  const dbSchema = {
    id: bigint,
    created: datetime(6),
    updated: datetime(6),
    version: bigint,
    team_id: bigint,
  }

  // Backend API
  const backend = {
    version: Integer,
    players: [
      {
        username: String,
        wristbandNumber: Integer,
        wristbandColor: Integer
      }
    ]
  }

  // Frontend
  const FRoster = [
    FPlayer,
  ]

#+end_src

*** Team schema

#+begin_src js

  // Datebase schema
  const dbSchema = {
    id: bigint,
    created: datetime(6),
    updated: datetime(6),
    last_register_attempt_time: datetime(6),
    name: varchar(32),
    state: varchar(255),
    total_points: int,
    latest_roster_id: bigint,
  }

  // Backend API
  const BTeam = {
    name: String,
    totalPoints: Integer,
    teamState: String,
    currentRoster: BRoster,
  }

  // Frontent
  const FTeam = {
    name: String,
    points: Integer,
    roster: FRoster,
    state: String, // forming, registered, merged
  }

#+end_src

*** Cashier schema
*** Mapping State functions

The general task of mapping properties from one name to another is not
difficult.

#+begin_src js

  // For example mapping the BWristband 'wristbandNumber' property to the FWrisband's 'id' property
  // is performed like so:

  const BWrisband = {
    wristbandNumber: Integer,
  }

  const FWristband = {
    id: BWristband.wristbandNumber,
  }

#+end_src

What needs more carefull thought is the notion of states. The backend subsystem
does not make use of states in the same way the frontend does. The frontend
implements nested state machines which require a detailed and distinct mapping
of each entities states at any point in time. The backend however, has no need
for such granularity. The little 'states' it needs it implements through the use
of 'random' properties scattered among the entities.

For example the *BWristband* uses the 'active' property to communicate that the
wristband is registered to some player.

However the *FWristband* uses the 'state' property to communicate:

1. The wristband is paired.
2. The wristband is not paired.
3. The wristband is in the process of being registered.
4. The wristband is registered.

Notice how the word 'paired' is used and not 'registered'. That is because the
wristband can be in the middle state of being attached to a user but without
being registered as such at least for some unknown length of time.

So the issue of state mapping becomes one where the frontend must reason a state
out of a Backend entity.

#+begin_src js

  // It is quite easy for the Wristband entity.

  const BWristband = {
    active: true,
  }

  const FWristband = {
    status: 'registered';
  }
  // Since the BWristband is active that means the FWristband
  // has superseded the states: unpaired, pairing, paired.

  // However what happens if the BWristband is found in the inactive state:

  const BWristband = {
    active: false,
    wrisbandNumber: 5,
  }

  // Hence there is no way of telling if the wristband 5 is either unpaired,
  // pairing or paired. The only way to know this is to search through the
  // frontend connected clients for the wristband 5. However that would be too
  // much of a pain so an inactive BWristband is interpreted to mean that the
  // wristband is in the unpaired state. If wristband 5 then ends up being used by
  // more that one connected client, then the client who tries and registers it
  // first to a player shall succeed whilst the second client shall fail.

  const FWristband = {
    status: 'unpaired'
  }

#+end_src

**** Wristband

#+begin_src js

  // active = true
  const BWristband = {
    active: true
  }
  const FWristband = {
    state: 'registered'
  }

  // active = false
  const BWristband = {
    active: false,
  }
  const FWristband = {
    state: 'paired'
  }

#+end_src

**** Player

#+begin_src js

  // wristbandMerged = true
  const BPlayer = {
    wristbandMerged: true
  }
  // Unfortunately one cannot discern just by the 'wristbandMerged' property if
  // the player's team is actually at this very moment playing. His team might
  // have paused the game. If one wanted to force checking, one would have to:
  // 1. Request a list of all active teams.
  // 2. Rule out those teams with a paused package.
  // 2. Loop through each remaining team roster.
  // 3. If a match is found the player is inGame otherwise he remains inTeam.
  const FPlayer = {
    state: 'inTeam'
  }


  // wristbandMerged = false
  // wristband.active = true
  const BPlayer = {
    wristbandMerged: false,
    wristband: {
      active: true,
    }
  }
  const FPlayer = {
    state: 'registered',
  }

  // wristbandMerged = false
  // wristband.active = false
  const BPlayer = {
    wristbandMerged: false,
    wristband: {
      active: false,
    }
  }
  // If a player is found within the backend subsystem that means in the least
  // that they are registered, which is why the registered instead of the
  // unregistered state is used.
  const FPlayer = {
    state: 'registered',
  }

#+end_src

*** Route data mapping
**** Rules
Each route accepts only frontend entities and returns frontend entities.

**** register player
***** inputs to route
#+begin_src js
  
#+end_src
input to route -> BPlayer | FPlayer

FPlayer -> BPlayer -> FPlayer

* LOG 24/07/23
** process of wristband registration
Check refactor.afadmin

** Standardizing route inputs and outputs
*** template

#+begin_src js

  // ROUTE INPUTS
  const RInput = "";

  // BACKEND INPUTS
  const BInput = "";

  // BACKEND OUTPUTS
  const BOutput = "";

  // ROUTE OUTPUTS
  const ROutput = "";

#+end_src

*** DONE Player registration
CLOSED: [2023-07-24 Mon 22:52]

#+begin_src js

  // ROUTE INPUTS
  const RInput = BPlayer || FPlayer || FLivePlayer || {
    player: BPlayer || FPlayer || FLivePlayer
  }

  // BACKEND INPUTS
  const BInput = {
    timestamp: Date.now(),
    username: String,
    surname: String,
    name: String,
    email: String,
    password: String,
  }

  // BACKEND OUTPUTS
  const BOutput = {
    result: String,
    message: String,
    validationErrors: [ name: "error", surname: "error", ],
  }

  // ROUTE OUTPUT
  const ROutput = FPlayer;

#+end_src

*** DONE Wristband registration
CLOSED: [2023-07-24 Mon 22:52]

#+begin_src js

  // ROUTE INPUTS
  const RInput = BPlayer || FPlayer || FLivePlayer || {
    player: BPlayer || FPlayer || FLivePlayer || String (username),
    wristband: BWristband || FWristband || FLiveWristband || Number (wristbandNumber)
  }

  // BACKEND INPUTS
  const BInput = {
    timestamp: Date.now(),
    username: String,
    wristbandNumber: Number,
  }

  // BACKEND OUTPUTS
  const BOutput = {
    result: String,
    message: String,
  }

  // ROUTE OUTPUTS
  const ROutput = FPlayer

#+end_src

*** DONE Wristband unregistration
CLOSED: [2023-07-24 Mon 23:25]

#+begin_src js

  // ROUTE INPUTS
  const RInput = BPlayer || FPlayer || FLivePlayer  || {
    player: BPlayer || FPlayer || FLivePlayer || String (username),
    wristband: BWristband || FWristband || FLiveWristband || Number (wristbandNumber)
  }

  // BACKEND INPUTS
  const BInput = {
    timestamp: Date.now(),
    username: String,
    wristbandNumber: Number,
  }

  // BACKEND OUTPUTS
  const BOutput = {
    result: String,
    message: String,
  }

  // ROUTE OUTPUTS
  const ROutput = FPlayer,

#+end_src

* LOG 25/07/23
** Implement and Test a LivePlayer's wristband pairing and registration
** Rename LivePlayer to PersistentPlayer
** create a class named TemporaryPlayer
* LOG 26/07/23
** player wristband registration process
* LOG 27/07/23
** team
team -> should fill its roster

* LOG 28/07/23
* LOG 01/08/23
** ScannedWristband
** VerifiedWristband
** RegisteredWristband
** TemporaryPlayer
** GroupParty
* LOG 03/08/23
** DONE Base entities should not be stateful
CLOSED: [2023-08-03 Thu 23:25]
** DONE Less calling normalize
CLOSED: [2023-08-03 Thu 23:25]
** TODO packages
* Lessons
** backend api should return the full schema of all related tables. JOIN etc.
* Administrator
** Cashout
*** Cash out button
*** TextArea comments
*** Number of packages added by cashier
*** Cashiers name
*** time of session start
*** time of session finish
*** all info that one can get from stats.
* Statistics
** amount of packages added throughout the day
use listTeams to count the total number of packages
** amount of packages added within the session
use localStorage
** amount of active packages within the session
use listTeams to fetch all teams and their packages
iterate over the teams packages
select those packages that have the active flag on.
** amount of inactive packages within the session
use listTeams to fetch all teams and their packages.
loop over the packages of each team
select inactive packages.
** amount of teams added throughout the day
use listTeams to fetch all teams.
length of list
** amount of teams added within the session
use localStorage
** amount of new players registered
use localStorage
** amount of playing players
use listTeams to fetch all teams.
iterate over all teams.
count the number of players in each teams roster.
** cost of packages added throughout the day
use listTeams to fetch all teams and their packages.
iterate over the teams and their packages.
get the sum of all package's cost of all teams.
** cost of packages within the session
use localStorage
** currently logged in cashiers.
** Number of cashiers that have logged in so far
* LocalStorage
* Styling tables
** expand cell over multiple columns (span)
colSpan='5'
** align cell contents
align='center | inherit | justify | left | right'

* LOG 17/08/23
** UI re-design
*** copy over popoverasyncstate and its dependecies
* LOG 22/08/23
** TODO Finish the registration ui page
* LOG 29/08/23
* log 05/09/23
** test if i can merge a temporary team
** check what happens when a merged team tries to re-merge
* LocationUi
** About
LocationHistoryUi is the temporary name used to collectively refer to all objects
designed towards the goal of:

UI navigation similar to react-router-dom combined with user actions.

A few words about react-router-dom so that one might get a grasp of the
functionality that LocationHistoryUi should emulate among its own unique set of
capabilities.

In very simple terms react-router-dom provides an interface by which a user may
declare the UI that should be rendered under a specified URL. React-router-dom
then makes sure that the rendered UI is the correct one using the browsers
History and Location web API's. It also allows nested UI's to share state among
other things.

Why re-design such functionality if one is already offered by react-router-dom?

The reason is that react-router-dom only allows rendering 2 routes
simultaneously if one splits the routes using a specific pattern but then one
loses the new Data Router functionality offered from version 6.0 and upwards.

As such i want to be able to continue using the new Data routers but at the same
time have a UI that is able to respond both on location and user actions.

* log 12/9/23
** UPDATE dependencies across all packages
*** DONE react-utils
CLOSED: [2023-09-12 Tue 14:25]

*** DONE js_utils
CLOSED: [2023-09-12 Tue 14:29]
*** DONE mqtt_proxy
CLOSED: [2023-09-12 Tue 14:29]
*** DONE afmachine
CLOSED: [2023-09-12 Tue 14:29]

** Integrate react-action-router

Removed history-toolbar context and related components from pageliveview
and pageTeam.


** TODO Remove history-toolbar component leftovers
** Create a panel-toolbar-router common to all panels
** Refactor pages to make use of the new panel-toolbar-router
* log 13/09/23
** PackageConfiguratorContext moved up the tree, remove unnecessary contexts
** complete package removal
* log 17-09-2023
** Finish the tables
